(function(){"use strict";const H=self,q=new Map,U=new Map;let re=1;const ae=8,ce=e=>{const k=U.get(e);k&&(U.delete(e),U.set(e,k))},I=e=>{typeof e!="number"||Number.isNaN(e)||q.set(e,{cancelled:!1})},Q=e=>{q.delete(e)},ie=e=>{const k=q.get(e);k&&(k.cancelled=!0)},D=e=>{const k=q.get(e);if(k&&k.cancelled)throw new DOMException("Operation cancelled by main thread","AbortError")},j=e=>{if(e instanceof DOMException)return{name:e.name,message:e.message,stack:e.stack??void 0};if(e instanceof Error)return{name:e.name,message:e.message,stack:e.stack??void 0};if(e&&typeof e=="object"&&"message"in e){const k=typeof e.message=="string"?e.message:"Unknown error",r=typeof e.name=="string"?e.name:void 0,E=typeof e.stack=="string"?e.stack:void 0;return{name:r,message:k,stack:E}}return{message:typeof e=="string"?e:"Unknown error"}};H.addEventListener("error",e=>{const k={...j(e.error??e.message??"Unknown worker error"),details:{filename:e.filename,lineno:e.lineno,colno:e.colno}};H.postMessage({id:-1,type:"worker_internal_error",payload:k}),e.preventDefault()}),H.addEventListener("unhandledrejection",e=>{const k=j(e.reason??"Unhandled rejection in worker");H.postMessage({id:-1,type:"worker_internal_error",payload:k}),e.preventDefault()});function le(e,k){const r={parameters:{},moleculeTypes:[],species:[],observables:[],reactions:[],reactionRules:[]};try{const s=pe(k);s&&(r.networkOptions=s)}catch{}const E=(s,i,o)=>{const x=($=>{const O={92:!0,94:!0,36:!0,42:!0,43:!0,63:!0,46:!0,40:!0,41:!0,124:!0,91:!0,93:!0,123:!0,125:!0};let u="";for(let g=0;g<$.length;g++){const S=$.charCodeAt(g);O[S]&&(u+="\\"),u+=$[g]}return u})(i),M=new RegExp("^\\s*begin\\s+"+x+"\\b","i"),d=new RegExp("^\\s*end\\s+"+x+"\\b","i"),_=o.split(/\r?\n/),R=[];let F=!1;for(const $ of _){D(s);const O=$.split("#")[0];if(!F){M.test(O)&&(F=!0);continue}if(d.test(O))break;R.push($)}return R.join(`
`).trim()},v=s=>s.trim().split("#")[0].trim(),p=(s,i)=>{let o=s.trim();const m=[],x=M=>{if(!M)return!1;const d=M.replace(/,$/,"").trim();return d===""?!1:Object.hasOwn(i,d)?!0:!Number.isNaN(parseFloat(d))};for(;o.length>0;){const M=o.lastIndexOf(" "),d=M===-1?o:o.slice(M+1);if(d.includes(",")){const _=d.split(",").map(R=>R.trim()).filter(Boolean);if(_.length>0&&_.every(x)){m.unshift(..._),o=M===-1?"":o.slice(0,M).trim();continue}}if(x(d)){m.unshift(d.replace(/,$/,"").trim()),o=M===-1?"":o.slice(0,M).trim();continue}break}return{productChunk:o.trim(),rateChunk:m.join(" ").trim()}},b=s=>{const i=[];let o="",m=0;for(let x=0;x<s.length;x++){const M=s[x];if(M==="(")m++;else if(M===")")m--;else if(M==="+"&&m===0){o.trim()&&i.push(o.trim()),o="";continue}o+=M}return o.trim()&&i.push(o.trim()),i},Z=E(e,"parameters",k);if(Z)for(const s of Z.split(/\r?\n/)){D(e);const i=v(s);if(i){const o=i.split(/\s+/);o.length>=2&&(r.parameters[o[0]]=parseFloat(o[1]))}}const z=E(e,"molecule types",k);if(z)for(const s of z.split(/\r?\n/)){D(e);const i=v(s);if(i){const o=i.match(/(\w+)\((.*?)\)/);if(o){const m=o[1],x=o[2].split(",").map(M=>M.trim()).filter(Boolean);r.moleculeTypes.push({name:m,components:x})}else r.moleculeTypes.push({name:i,components:[]})}}const W=E(e,"seed species",k);if(W)for(const s of W.split(/\r?\n/)){D(e);const i=v(s);if(!i)continue;const o=i.match(/^(\S+)\s+(.+)$/);if(!o)continue;const m=o[1],x=o[2].trim();let M=0;try{let d=x;for(const[F,$]of Object.entries(r.parameters||{})){const O=new RegExp("\\b"+F.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")+"\\b","g");d=d.replace(O,String($))}const R=new Function("return ("+d+")")();M=typeof R=="number"&&Number.isFinite(R)?R:parseFloat(x)||0}catch{if(x in(r.parameters||{}))M=r.parameters[x]??0;else{const _=parseFloat(x);M=Number.isFinite(_)?_:0}}m&&!Number.isNaN(M)&&r.species.push({name:m,initialConcentration:M})}const N=E(e,"observables",k);if(N)for(const s of N.split(/\r?\n/)){D(e);const i=v(s);if(i){const o=i.split(/\s+/);if(o.length>=3){const x=o[0].toLowerCase()==="species"?"species":"molecules";r.observables.push({type:x,name:o[1],pattern:o.slice(2).join(" ")})}}}const L=E(e,"reaction rules",k);if(L){const s=[];let i="";for(const o of L.split(/\r?\n/)){D(e);const m=v(o);m&&(m.endsWith("\\")?i+=m.slice(0,-1).trim()+" ":(i+=m,s.push(i.trim()),i=""))}i.trim()&&s.push(i.trim()),s.forEach(o=>{D(e);let m=o;const x=m.match(/^[^:]+:\s*(.*)$/);x&&(m=x[1]);const M=m.includes("<->"),d=m.split(M?"<->":"->");if(d.length<2){console.warn("[Worker] Rule parsing failed - not enough parts:",o);return}const _=d[0].trim(),R=d[1].trim(),F=b(_);if(F.length===0)return;const{productChunk:$,rateChunk:O}=p(R,r.parameters);if(!O)return;const u=b($);if(u.length===0)return;const g=O.split(",").reduce((w,A)=>(A.trim().split(/\s+/).filter(Boolean).forEach(y=>w.push(y)),w),[]);if(g.length===0)return;const S=g[0],n=g[1],c={reactants:F,products:u,rate:S,isBidirectional:M,reverseRate:M?n:void 0};r.reactionRules.push(c)})}return r.reactionRules.forEach(s=>{const i=r.parameters[s.rate]??parseFloat(s.rate);if(Number.isNaN(i)||r.reactions.push({reactants:s.reactants,products:s.products,rate:s.rate,rateConstant:i}),s.isBidirectional&&s.reverseRate){const o=r.parameters[s.reverseRate]??parseFloat(s.reverseRate);Number.isNaN(o)||r.reactions.push({reactants:s.products,products:s.reactants,rate:s.reverseRate,rateConstant:o})}}),r}function pe(e){if(!e)return;const k=e.match(/generate_network\s*\(\s*\{([\s\S]*?)\}\s*\)/i);if(!k)return;const r=k[1],E={},v=r.match(/max_agg\s*=>\s*([\d.eE+\-]+)/i);v?E.maxAgg=parseFloat(v[1]):E.maxAgg=1e99;const p=r.match(/max_iter\s*=>\s*(\d+)/i);p?E.maxIter=parseInt(p[1],10):E.maxIter=100;const b=r.match(/overwrite\s*=>\s*(true|false)/i);b&&(E.overwrite=b[1].toLowerCase()==="true");const Z=r.match(/max_stoich\s*=>\s*\{([\s\S]*?)\}/i);if(Z){const W=Z[1].split(",").map(L=>L.trim()).filter(Boolean),N={};for(const L of W){const s=L.split("=>");if(s.length>=2){const i=s[0].trim().replace(/^['"]|['"]$/g,""),o=parseInt(s[1].trim(),10);i&&!Number.isNaN(o)&&(N[i]=o)}}E.maxStoich=N}return E}function ne(e){const k=[];let r=0,E="";for(let v=0;v<e.length;v++){const p=e[v];if(p==="("?r++:p===")"&&(r=Math.max(0,r-1)),p==="."&&r===0){E.trim()&&k.push(E.trim()),E="";continue}E+=p}return E.trim()&&k.push(E.trim()),k}function me(e,k){const r=JSON.parse(JSON.stringify(k)),E=k.networkOptions??{maxIter:100,maxAgg:1e99},v=E.maxIter??100,p=E.maxAgg??1e99,b=E.maxStoich??{},Z=6e4,z=500,W=Date.now();let N=Date.now(),L=0;const s={...b||{}},i=n=>typeof n=="string"?n.trim():"",o=n=>n?n.split(",").map(c=>c.trim()).filter(c=>c.length>0):[],m=n=>n.split("~")[0].split("!")[0],x=n=>{const c=n.match(/^([^~]+)~(.+)$/);if(c){const w=c[1],A=c[2].split("~")[0];return`${w}~${A}`}return n},M=n=>{if(n.includes("."))return n.split(".").map(t=>M(t.trim())).join(".");const c=n.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(!c){const t=r.moleculeTypes.find(a=>a.name===n);if(t&&t.components.length>0){const a=t.components.map(x);return`${n}(${a.join(",")})`}return n}const w=c[1],A=c[2].split(",").map(t=>t.trim()).filter(Boolean),y=r.moleculeTypes.find(t=>t.name===w);if(!y)return n;const f=[];return y.components.forEach(t=>{const a=m(t),h=A.find(l=>m(l)===a);h?f.push(h):f.push(x(t))}),A.forEach(t=>{const a=m(t);f.some(h=>m(h)===a)||f.push(t)}),`${w}(${f.join(",")})`},d=(n,c)=>{if(n===c)return!0;const w=(f,t)=>{const a=f.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/),h=t.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(!a||!h)return f===t;if(a[1]!==h[1])return!1;const l=o(a[2]),C=o(h[2]);return l.every(G=>{const B=m(G);return C.some(T=>{const P=m(T);return B!==P?!1:G.includes("~")||G.includes("!")?G===T:!T.includes("!")})})},A=n.includes("."),y=c.includes(".");if(A){const f=n.split(".").map(a=>i(a));if(!y)return!1;const t=c.split(".").map(a=>i(a));if(f.length!==t.length)return!1;for(let a=0;a<f.length;a+=1)if(!w(f[a],t[a]))return!1;return!0}return y?c.split(".").map(t=>i(t)).some(t=>w(n,t)):w(n,c)},_=(n,c)=>{if(!n||!c||c.includes("."))return null;const w=c.match(/^([A-Za-z0-9_]+)\(([^)]*)\)$/);if(!w)return null;const A=w[1],y=o(w[2]),f=ne(n).map(h=>i(h));let t=!1;const a=f.map(h=>{const l=h.match(/^([A-Za-z0-9_]+)\(([^)]*)\)$/);if(!l||l[1]!==A)return h;const C=o(l[2]),G={};C.forEach(T=>{G[m(T)]=T}),y.forEach(T=>{G[m(T)]=T});const B=[];return C.forEach(T=>{const P=m(T);Object.prototype.hasOwnProperty.call(G,P)?(B.push(G[P]),delete G[P]):B.push(T)}),Object.keys(G).forEach(T=>{B.push(G[T])}),t=!0,`${A}(${B.join(",")})`});return t?a.join("."):null},R=(n,c=0,w=[])=>{if(c===n.length)return[w];const A=[],y=n[c]??[];for(let f=0;f<y.length;f+=1){const t=y[f],a=w.concat([t]),h=R(n,c+1,a);for(let l=0;l<h.length;l+=1)A.push(h[l])}return A},F=JSON.parse(JSON.stringify(r.reactions)),$=new Map(r.species.map(n=>[n.name,{...n}])),O=new Map;let u=!0;for(;u;){D(e),L+=1,u=!1;const n=Array.from($.values());if(L>v){H.postMessage({id:e,type:"warning",payload:{jobId:e,message:`Network generation halted after reaching max_iter=${v} iterations.`}});break}if(Date.now()-W>Z){const c=$.size;throw new Error(`Network generation timed out after ${Math.round((Date.now()-W)/1e3)}s.

Generated ${c} species in ${L} iterations.

To prevent timeouts, add constraints to your model:

generate_network({
  max_iter=>${v},
  max_agg=>${p},
  max_stoich=>{ /* e.g. TGFb=>3,IL6=>3 */ }
})

Or use desktop BioNetGen for unlimited generation.`)}for(const c of F){D(e);const w=c.reactants.map(y=>{const f=n.filter(t=>d(y,t.name));return f.length===0&&(y.includes("!")||y.includes("."))?[{name:y,initialConcentration:0}]:f});if(w.some(y=>y.length===0))continue;R(w).forEach(y=>{if(D(e),Date.now()-W>Z){const l=$.size;throw new Error(`Network generation timed out after ${Math.round((Date.now()-W)/1e3)}s.

Generated ${l} species in ${L} iterations.

To prevent timeouts, add constraints to your model:

generate_network({
  max_iter=>${v},
  max_agg=>${p},
  max_stoich=>{ /* e.g. TGFb=>3,IL6=>3 */ }
})

Or use desktop BioNetGen for unlimited generation.`)}if(Date.now()-N>z){const l=$.size,C=O.size;H.postMessage({id:e,type:"progress",payload:{jobId:e,message:`Generating network: ${l} species, ${C} reactions`,speciesCount:l,reactionCount:C}}),N=Date.now()}const f={reactants:y.map(l=>l.name),products:c.products.map(l=>{if(c.reactants.length===1&&c.products.length===1&&y.length===1){const C=_(y[0].name,l);if(C)return C}return l.includes("(")?ne(l).map(B=>{const T=B.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(!T)return B;const P=T[1],te=T[2];let ee=y.find(K=>K.name.startsWith(`${P}(`));if(!ee){for(const K of y)if(K.name.includes(".")){const V=K.name.split(".").find(X=>X.startsWith(`${P}(`));if(V){ee={name:V,initialConcentration:K.initialConcentration};break}}}if(ee){const K=ee.name.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(K){const oe=K[2].split(",").map(J=>J.trim()).filter(Boolean),V=te.split(",").map(J=>J.trim()).filter(Boolean),X=J=>J.split("~")[0].split("!")[0],se=V.slice(),fe=V.reduce((J,Y)=>(J[X(Y)]=Y,J),{});return oe.forEach(J=>{const Y=X(J);Object.prototype.hasOwnProperty.call(fe,Y)||se.some(de=>X(de)===Y)||se.push(J)}),`${P}(${se.join(",")})`}}return B}).join("."):l}),rate:c.rate,rateConstant:c.rateConstant},t=l=>{const C={},G=l.split(".").map(B=>B.trim()).filter(Boolean);for(const B of G){const T=B.match(/^([A-Za-z0-9_]+)/),P=T?T[1]:B;C[P]=(C[P]||0)+1}return C},a=f.products.map(l=>M(l));if(p!==void 0&&a.some(l=>l.split(".").length>p))return;if(Object.keys(s).length>0){let l=!1;for(const C of a){const G=t(C);for(const[B,T]of Object.entries(G)){const P=s[B];if(typeof P=="number"&&T>P){l=!0;break}}if(l)break}if(l)return}const h=`${f.reactants.join("+")}->${a.join("+")}::${String(f.rate)}`;if(!O.has(h)){const l={...f,products:a};O.set(h,l);for(const C of a)$.has(C)||($.set(C,{name:C,initialConcentration:0}),u=!0)}})}}const g=new Set;for(const n of r.reactions)D(e),n.products.forEach(c=>{const w=M(c);g.add(w),n.products=n.products.map(A=>A===c?w:A)});const S=new Set(r.species.map(n=>n.name));for(const n of g)D(e),S.has(n)||(r.species.push({name:n,initialConcentration:0}),S.add(n));return r}function ue(e,k,r){D(e);const E=me(e,k),v=JSON.parse(JSON.stringify(E)),{t_end:p,n_steps:b,method:Z}=r,z=v.species.map(s=>s.name),W=["time",...v.observables.map(s=>s.name)],N=s=>{const i={},o=d=>d.split(",").map(_=>_.trim()).filter(Boolean),m=d=>d.split("~")[0].split("!")[0],x=(d,_)=>{const R=d.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/),F=_.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(!R||!F)return d===_;if(R[1]!==F[1])return!1;const $=o(R[2]),O=o(F[2]);return $.every(u=>{const g=m(u);return O.some(S=>{const n=m(S);return g!==n?!1:u.includes("~")||u.includes("!")?u===S:!S.includes("!")})})},M=(d,_)=>{if(d===_)return!0;const R=d.includes("."),F=_.includes(".");if(R){const $=d.split(".").map(u=>u.trim());if(!F)return!1;const O=_.split(".").map(u=>u.trim());if($.length!==O.length)return!1;for(let u=0;u<$.length;u+=1)if(!x($[u],O[u]))return!1;return!0}return F?_.split(".").map(O=>O.trim()).some(O=>x(d,O)):x(d,_)};for(const d of v.observables){D(e);let _=0;const R=d.pattern?String(d.pattern).trim():"",$=(d.type??"molecules")==="species";for(const[O,u]of Object.entries(s)){if(D(e),!u)continue;if($){M(R,O)&&(_+=u);continue}if(R.includes("."))M(R,O)&&(_+=u);else{const S=O.split(".").map(c=>c.trim()).filter(Boolean);let n=!1;for(const c of S)if(D(e),x(R,c)){n=!0;break}n&&(_+=u)}}i[d.name]=_}return i},L=[];if(Z==="ssa"){let s=Object.fromEntries(v.species.map(x=>[x.name,Math.round(x.initialConcentration)]));const i=p/b;let o=0,m=0;for(L.push({time:o,...N(s)});o<p;){D(e);const x=[];for(const u of v.reactions){D(e);let g=u.rateConstant;for(const S of u.reactants){const n=s[S];n===void 0&&console.warn("[SSA] Missing reactant in counts:",S,"Available:",Object.keys(s)),g*=n||0}x.push(g)}const M=x.reduce((u,g)=>u+g,0);if(M===0)break;const d=Math.random(),_=1/M*Math.log(1/d);o+=_;const R=Math.random()*M;let F=0,$=x.length-1;for(let u=0;u<x.length;u+=1)if(D(e),F+=x[u],R<=F){$=u;break}const O=v.reactions[$];for(const u of O.reactants){const g=s[u]||0;s[u]=g-1}for(const u of O.products){const g=s[u]||0;s[u]=g+1}for(;o>=m&&m<=p;)D(e),L.push({time:Math.round(m*1e10)/1e10,...N(s)}),m+=i}for(;m<=p;)D(e),L.push({time:Math.round(m*1e10)/1e10,...N(s)}),m+=i;return{headers:W,data:L}}if(Z==="ode"){let s=v.species.map(g=>g.initialConcentration);const i=()=>D(e),o=(g,S)=>{if(i(),g===S)return!0;const n=t=>t.split(",").map(a=>a.trim()).filter(Boolean),c=t=>t.split("~")[0].split("!")[0],w=t=>t.trim(),A=(t,a)=>{const h=t.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/),l=a.match(/^([A-Za-z0-9_]+)\(([^)]*)\)/);if(!h||!l)return t===a;if(h[1]!==l[1])return!1;const C=n(h[2]),G=n(l[2]);return C.every(B=>{const T=c(B);return G.some(P=>{const te=c(P);return T!==te?!1:B.includes("~")||B.includes("!")?B===P:!P.includes("!")})})},y=g.includes("."),f=S.includes(".");if(y){const t=g.split(".").map(h=>w(h));if(!f)return!1;const a=S.split(".").map(h=>w(h));if(t.length!==a.length)return!1;for(let h=0;h<t.length;h+=1)if(!A(t[h],a[h]))return!1;return!0}return f?S.split(".").map(a=>w(a)).some(a=>A(g,a)):A(g,S)},m=(g,S)=>{i();const n={};z.forEach((w,A)=>{n[w]=g[A]});const c=new Array(z.length).fill(0);return v.reactions.forEach(w=>{if(i(),w.reactants.every(y=>z.includes(y))){let y=w.rateConstant;w.reactants.forEach(f=>{y*=n[f]||0}),w.reactants.forEach(f=>{const t=z.indexOf(f);t!==-1&&(c[t]-=y)}),w.products.forEach(f=>{const t=z.indexOf(f);if(t!==-1)c[t]+=y;else for(let a=0;a<z.length;a+=1)if(o(f,z[a])){c[a]+=y;break}})}else{const y=w.reactants.map(t=>{const a=[];return z.forEach((h,l)=>{o(t,h)&&a.push({name:h,idx:l})}),a});if(!y.every(t=>t.length===1))return;let f=w.rateConstant;if(y.forEach(t=>{f*=n[t[0].name]||0}),f===0)return;y.forEach(t=>{c[t[0].idx]-=f}),w.products.forEach(t=>{const a=z.indexOf(t);if(a!==-1)c[a]+=f;else for(let h=0;h<z.length;h+=1)if(o(t,z[h])){c[h]+=f;break}})}}),c},x=(g,S,n)=>{i();const c=m(g),w=g.map((l,C)=>l+.5*S*c[C]),A=m(w),y=g.map((l,C)=>l+.5*S*A[C]),f=m(y),t=g.map((l,C)=>l+S*f[C]),a=m(t);return g.map((l,C)=>l+S/6*(c[C]+2*A[C]+2*f[C]+a[C])).map(l=>Math.max(0,l))},M=p/b;let d=0;const _={};z.forEach((g,S)=>{_[g]=s[S]}),L.push({time:d,...N(_)});const R=r.steadyStateTolerance??1e-6,F=r.steadyStateWindow??5,$=!!r.steadyState;let O=0,u=!1;for(let g=1;g<=b&&!u;g+=1){i();const S=g*M,n=v.reactions.reduce((t,a)=>Math.max(t,a.rateConstant||0),0),c=Math.max(1,n*100),w=Math.max(10,Math.ceil(M*10*c)),A=(S-d)/w;let y=d;for(;y<S-1e-12;){i();let t=Math.min(A,S-y),a=0,h=null;const l=12,C=1e12;for(;a<l;){i();const B=x(s,t);if(!B.some(P=>!Number.isFinite(P)||Math.abs(P)>C)){h=B;break}if(t/=2,a+=1,t<1e-12)break}if(!h)throw new Error("Simulation became unstable (adaptive RK4 step failed). Try adjusting parameters or using the SSA solver.");const G=Math.max(...h.map((B,T)=>Math.abs(B-s[T])));if(s=h,y+=t,$)if(G<=R){if(O+=1,O>=F){u=!0;break}}else O=0}d=y;const f={};if(z.forEach((t,a)=>{f[t]=s[a]}),L.push({time:Math.round(d*1e10)/1e10,...N(f)}),u)break}return{headers:W,data:L}}throw new Error(`Unsupported simulation method: ${Z}`)}H.addEventListener("message",e=>{const k=e.data;if(!k||typeof k!="object"){console.warn("[Worker] Received malformed message",k);return}const{id:r,type:E,payload:v}=k;if(typeof r!="number"||typeof E!="string"){console.warn("[Worker] Missing id or type on message",k);return}if(E==="cancel"){const p=v&&typeof v=="object"?v.targetId:void 0;typeof p=="number"&&ie(p);return}if(E==="parse"){I(r);try{const b=le(r,typeof v=="string"?v:""),Z={id:r,type:"parse_success",payload:b};H.postMessage(Z)}catch(p){const b={id:r,type:"parse_error",payload:j(p)};H.postMessage(b)}finally{Q(r)}return}if(E==="simulate"){I(r);try{if(!v||typeof v!="object")throw new Error("Simulation payload missing");const p=v;let b;const Z=p.options;if(p.model)b=p.model;else if(typeof p.modelId=="number"){const N=U.get(p.modelId);if(!N)throw new Error("Cached model not found in worker");if(ce(p.modelId),!p.parameterOverrides||Object.keys(p.parameterOverrides).length===0)b=N;else{const L=p.parameterOverrides,s={...N,parameters:{...N.parameters||{},...L},reactions:[]};(N.reactions||[]).forEach(i=>{const o=s.parameters[i.rate]??parseFloat(i.rate);s.reactions.push({...i,rateConstant:o})}),b=s}}if(!b||!Z)throw new Error("Simulation payload incomplete");const z=ue(r,b,Z),W={id:r,type:"simulate_success",payload:z};H.postMessage(W)}catch(p){const b={id:r,type:"simulate_error",payload:j(p)};H.postMessage(b)}finally{Q(r)}return}if(E==="cache_model"){I(r);try{const p=v,b=p&&p.model?p.model:void 0;if(!b)throw new Error("Cache model payload missing");const Z=re++,z={...b,parameters:{...b.parameters||{}},moleculeTypes:(b.moleculeTypes||[]).map(N=>({...N})),species:(b.species||[]).map(N=>({...N})),observables:(b.observables||[]).map(N=>({...N})),reactions:(b.reactions||[]).map(N=>({...N})),reactionRules:(b.reactionRules||[]).map(N=>({...N}))};U.set(Z,z);try{if(U.size>ae){const L=U.keys().next().value;typeof L=="number"&&(U.delete(L),console.warn("[Worker] Evicted cached model (LRU) id=",L))}}catch{}const W={id:r,type:"cache_model_success",payload:{modelId:Z}};H.postMessage(W)}catch(p){const b={id:r,type:"cache_model_error",payload:j(p)};H.postMessage(b)}finally{Q(r)}return}if(E==="release_model"){I(r);try{const p=v,b=p&&typeof p=="object"?p.modelId:void 0;if(typeof b!="number")throw new Error("release_model payload missing modelId");const Z=U.delete(b),z={id:r,type:"release_model_success",payload:{modelId:b}};H.postMessage(z)}catch(p){const b={id:r,type:"release_model_error",payload:j(p)};H.postMessage(b)}finally{Q(r)}return}console.warn("[Worker] Unknown message type received:",E)})})();
